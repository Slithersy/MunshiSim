#include "interfaces/Map_Interface.hps"
#include "base/Inputhandler_Types.hps"

#include "helpers/helper_player.hps"
#include "helpers/helper_map.hps"
#include "helpers/helper_props.hps"
#include "helpers/helper_effects.hps"
#include "helpers/helper_audio.hps"
#include "helpers/helper_imgui.hps"
#include "helpers/helper_sequences.hps"
#include "helpers/helper_game.hps"
#include "helpers/helper_modules.hps"
#include "helpers/helper_ai.hps"
#include "helpers/helper_custom.hps"

//--------------------------------------------------
 
/*Place any global values here. These must be const variables as they will not be saved*/
/*This is also the place for enums and classes, but these should be avoided whenever possible*/
 
//--------------------------------------------------
 
class cScrMap : iScrMap
{
	//--------------------------------------------
 
	//////////////////////////////////////////////////////////////////////////////////////////
	// ==============
	// MAIN CALLBACKS
	// ==============
	//{///////////////////////////////////////////////////////////////////////////////////////
 
	//-------------------------------------------------------
 
	////////////////////////////
	// Set up map environment
	void Setup()
	{
	
	}
	
	//-------------------------------------------------------

	////////////////////////////
	// Run first time starting map
	void OnStart()
	{
		
	}

	//-------------------------------------------------------

	////////////////////////////
	// Run when entering map
	void OnEnter()
	{
        MovePedestrians();
        Seq_Truck("");
        
        Lamp_SetLit("Special_SpotLight_*", false, false);
        Lamp_SetLit("SideLamp_*", false, false);
        Lamp_SetLit("lamp_roof_large_noeffect_*", false, false);
        Light_SetVisible("Special_Spot_*", false);
        Light_SetVisible("Special_Point_*", false);
        Light_SetVisible("BoxLight_Biggy_*", false);
        Light_SetVisible("RailPoint_*", false);
        Light_SetVisible("SidePoint_*", false);
        Light_SetVisible("SideBox_*", false);
	}

	//-------------------------------------------------------

	////////////////////////////
	// Run when leaving map
	void OnLeave()
	{
	}

	//-------------------------------------------------------

	////////////////////////////
	// The player has died.
	void OnPlayerKilled(int alRecentDeaths, const tString&in asSource)
	{
	}

	//-------------------------------------------------------
    
	void MovePedestrians()
	{
		Pathfinder_Track_Add("subway_businessman_1", "PathNodeArea_1");
		Pathfinder_Track_Add("subway_businessman_1", "PathNodeArea_8");
		Pathfinder_Track_Add("subway_businessman_1", "PathNodeArea_11");
        Pathfinder_Track_Add("subway_businessman_1", "PathNodeArea_22");
        Pathfinder_Track_Add("subway_businessman_1", "PathNodeArea_26");
        Pathfinder_Track_Add("subway_businessman_1", "PathNodeArea_41");
		Pathfinder_Track_Add("subway_businessman_1", "PathNodeArea_47",5.0f,10.0f);
		Pathfinder_Track_Start("subway_businessman_1",true);
	}
    
	cSequenceStatesData mSeqTruck;
	void Seq_Truck(const tString& in asName="")
	{
		Sequence_Begin("Seq_Truck", mSeqTruck);
		
		if (Sequence_DoStepAndPause())
		{
			Prop_MoveLinearTo("Truck","Truck_RESET",70,70,0.2f,true,"OnTruckReachedTarget");
			Prop_AlignRotation("Truck","Truck_RESET",9,9,1.0f,true,"");
        }
		else if (Sequence_DoStepAndPause())
		{
			Prop_MoveLinearTo("Truck","Truck_1",7,7,0.2f,false,"OnTruckReachedTarget");
			Prop_AlignRotation("Truck","Truck_1",0.5,1,1.0f,false,"");
		}
		else if (Sequence_DoStepAndPause())
		{
			Prop_MoveLinearTo("Truck","Truck_2",7,7,0.2f,false,"OnTruckReachedTarget");
			Prop_AlignRotation("Truck","Truck_2",0.5,1,1.0f,false,"");
		}
		else if (Sequence_DoStepAndPause())
		{
			Prop_MoveLinearTo("Truck","Truck_3",7,7,0.2f,false,"OnTruckReachedTarget");
			Prop_AlignRotation("Truck","Truck_3",0.5,1,1.0f,false,"");
		}
		else if (Sequence_DoStepAndPause())
		{
			Prop_MoveLinearTo("Truck","Truck_4",7,7,0.2f,false,"OnTruckReachedTarget");
			Prop_AlignRotation("Truck","Truck_4",0.5,1,1.0f,false,"");
		}
		else if (Sequence_DoStepAndPause())
		{
			Prop_MoveLinearTo("Truck","Truck_5",7,7,0.2f,false,"OnTruckReachedTarget");
			Prop_AlignRotation("Truck","Truck_5",0.5,1,1.0f,false,"");
		}
		else if (Sequence_DoStepAndPause())
		{
			Prop_MoveLinearTo("Truck","Truck_6",7,7,0.2f,false,"OnTruckReachedTarget");
			Prop_AlignRotation("Truck","Truck_6",0.5,1,1.0f,false,"");
		}
		else if (Sequence_DoStepAndPause())
		{
			Prop_MoveLinearTo("Truck","Truck_7",7,7,0.2f,false,"OnTruckReachedTarget");
			Prop_AlignRotation("Truck","Truck_7",0.5,1,1.0f,false,"");
		}
		else if (Sequence_DoStepAndPause())
		{
			Prop_MoveLinearTo("Truck","Truck_8",7,7,0.2f,false,"OnTruckReachedTargetFinal");
			Prop_AlignRotation("Truck","Truck_8",0.5,1,1.0f,false,"");
		}
		
		Sequence_End();
	}
	
	//-------------------------------------------------------
	
	void OnTruckReachedTarget(const tString&in asName)
	{
		SequenceStates_Resume("Seq_Truck");
	}
    
	void OnTruckReachedTargetFinal(const tString&in asName)
	{
		Map_AddTimer("RedoTrucks", 10.0f, "RedoTrucks");
	}
    
    void RedoTrucks(const tString&in asTimer) 
    {
        Seq_Truck("");
        SequenceStates_Resume("Seq_Truck");
    }
    

	////////////////////////////
	// To get when player makes input (mostly used for debug)
	void OnAction(int alAction, bool abPressed) 
	{
		if(abPressed==false) return;
		
		if(alAction == eAction_Test1)
		{
		}
	}

	//-------------------------------------------------------

	////////////////////////////
	// This only used for pure debug purposes when info needs to printed.
	float DrawDebugOutput(cGuiSet @apSet,iFontData @apFont,float afY)
	{
		//afY = cLux_DrawDebugText("My Debug value:"+..., afY);
		return afY;
	}
 
	//-------------------------------------------------------
 
	//} END MAIN CALLBACKS
 
 
	//////////////////////////////////////////////////////////////////////////////////////////
	// ==============
	// MAIN FUNCTIONS
	// ==============
	//{///////////////////////////////////////////////////////////////////////////////////////
 
	//-------------------------------------------------------
 
	/*Put any variables that are used in more than one scene here.*/
 
	//-------------------------------------------------------
 
	/*Put any functions that are used in more than one scene here.*/
 
	//-------------------------------------------------------
 
	//} END MAIN FUNCTIONS
 
	//////////////////////////////////////////////////////////////////////////////////////////
	// ==============
	// SCENE KEYPAD *KEYPAD SECTIONS*
	// ==============
	//{//////////////////////////////////////////////////////////////////////////////////////
	//-------------------------------------------------------
    float mfKeypadPulse = 0;
	bool mbUsingKeypad = false;
	tString msPadCode = "";
    tString gsKeypadCode = "2503";
    
	void SetKeypadMaterial(const tString &in asEntity, const tString &in asMaterial)
	{
		iLuxEntity@ pEntity = cLux_GetCurrentMap().GetEntityByName(asEntity, eLuxEntityType_LastEnum, "");
		cMaterial@ pMaterial = cResources_CreateMaterial(asMaterial);

		pEntity.GetMeshEntity().GetSubMeshEntity(1).SetCustomMaterial(pMaterial, false);
	}
	
	//-------------------------------------------------------
	
	void Keypad_EnterDigit(const tString &in asDigit, const tString &in asEntity)
	{
        if (asEntity=="Keypad1")
            gsKeypadCode = "2503";
        else if (asEntity=="Keypad2") 
            gsKeypadCode = "2501";
        else gsKeypadCode = "";
		
		///////////////////////
		// Append digit to code
		msPadCode = msPadCode + asDigit; 
		if (msPadCode != cString_Sub(gsKeypadCode, 0, msPadCode.length()))
		{
			tString sFirstCodeChar = cString_Sub(gsKeypadCode, 0, 1);
			if (asDigit==sFirstCodeChar)
				msPadCode = asDigit;
			else
				msPadCode = "";
		}
		
		///////////////////////
		// Keypad sound
		Sound_CreateAtEntity("EnterDigit","Entities_Urban/tech/keypad/keypad_press_01",asEntity,0.0,false);
		
		//////////////////////
		// Check complete code
		if (msPadCode.length() < gsKeypadCode.length())
		{
			Entity_SetEffectsActive(ImGui_GetName(), false, false);
			Map_AddTimer(asEntity, 0.1, "Timer_KeypadEffectsOn");
			Light_FadeTo(asEntity+"_PointLight_1",0,0.1,0);
			return;
		}
		
		/////////////////////
		// Unlock door on correct code
		if (msPadCode==gsKeypadCode)
		{
			// Change to green light
			SetKeypadMaterial(asEntity,"security_keypad_greenlamp");
			Light_FadeTo(asEntity+"_PointLight_1",cColor_Green,0.1,0);
			
			// Deactivate gui and return player to normal
			Terminal_SetGuiActive(ImGui_GetName(),false);	
			Player_ChangeStateToNormal();
            
            if (asEntity=="Keypad1")
                SlideDoor_SetOpenAmount(asEntity+"_Door", 1.0f, false);
            else SwingDoor_SetLocked(asEntity+"_Door",false,true);
			// Sounds
			Sound_CreateAtEntity("KeypdOpen","Entities_Urban/tech/keypad/keypad_correct",asEntity,0.0,false);
            Sound_CreateAtEntity("DoorUnlockSound","Entities_Urban/door/wooden_door_metal_latch_medium_room/interact_unlock",asEntity+"_Door",0.0,false);
		}
	}
    
	/////////////////////////////////////////////////////////
	// TERMINAL KEYPAD
	/////////////////////////////////////////////////////////
	
	//-------------------------------------------------------
	
	void security_keypad_1_OnGui(const tString&in asEntityName, float afTimeStep)
	{
		////////////////////////
		// Buttons are transparent
		cImGuiButtonData button;
		button.mvDefaultSize = cVector2f(10,10);
		button.mColorBase = cColor(0.3,0.3,0.3,0);
		button.mbUseInFocusGfx = mbUsingKeypad;
		button.mGfxInFocus.SetFile("urban/keypad/keypad_Selected");
	
		
		////////////////////////
		// Position buttonspath
		bool bNumPad1 = ImGui_DoButtonExt("ButtonKeypad1","",button, ImGui_NrmPosGroup(cVector3f(0.27, 0.33, 0)), ImGui_NrmSizeGroup(cVector2f(0.07, 0.07)));
		bool bNumPad2 = ImGui_DoButtonExt("ButtonKeypad2","",button, ImGui_NrmPosGroup(cVector3f(0.38, 0.33, 0)), ImGui_NrmSizeGroup(cVector2f(0.07, 0.07)));
		bool bNumPad3 = ImGui_DoButtonExt("ButtonKeypad3","",button, ImGui_NrmPosGroup(cVector3f(0.48, 0.33, 0)), ImGui_NrmSizeGroup(cVector2f(0.07, 0.07)));
		bool bNumPad4 = ImGui_DoButtonExt("ButtonKeypad4","",button, ImGui_NrmPosGroup(cVector3f(0.27, 0.43, 0)), ImGui_NrmSizeGroup(cVector2f(0.07, 0.07)));
		bool bNumPad5 = ImGui_DoButtonExt("ButtonKeypad5","",button, ImGui_NrmPosGroup(cVector3f(0.38, 0.43, 0)), ImGui_NrmSizeGroup(cVector2f(0.07, 0.07)));
		bool bNumPad6 = ImGui_DoButtonExt("ButtonKeypad6","",button, ImGui_NrmPosGroup(cVector3f(0.48, 0.43, 0)), ImGui_NrmSizeGroup(cVector2f(0.07, 0.07)));
		bool bNumPad7 = ImGui_DoButtonExt("ButtonKeypad7","",button, ImGui_NrmPosGroup(cVector3f(0.27, 0.53, 0)), ImGui_NrmSizeGroup(cVector2f(0.07, 0.07)));
		bool bNumPad8 = ImGui_DoButtonExt("ButtonKeypad8","",button, ImGui_NrmPosGroup(cVector3f(0.38, 0.53, 0)), ImGui_NrmSizeGroup(cVector2f(0.07, 0.07)));
		bool bNumPad9 = ImGui_DoButtonExt("ButtonKeypad9","",button, ImGui_NrmPosGroup(cVector3f(0.48, 0.53, 0)), ImGui_NrmSizeGroup(cVector2f(0.07, 0.07)));
		bool bNumPadAst = ImGui_DoButtonExt("ButtonKeypadA","",button, ImGui_NrmPosGroup(cVector3f(0.27, 0.63, 0)), ImGui_NrmSizeGroup(cVector2f(0.07, 0.07)));
		bool bNumPad0 = ImGui_DoButtonExt("ButtonKeypad0","",button, ImGui_NrmPosGroup(cVector3f(0.38, 0.63, 0)), ImGui_NrmSizeGroup(cVector2f(0.07, 0.07)));
		bool bNumPadHash = ImGui_DoButtonExt("ButtonKeypadH","",button, ImGui_NrmPosGroup(cVector3f(0.48, 0.63, 0)), ImGui_NrmSizeGroup(cVector2f(0.07, 0.07)));
		
		////////////////////////
		// Enter key code
		if (bNumPad1) 	{ Keypad_EnterDigit("1", asEntityName); }
		if (bNumPad2) 	{ Keypad_EnterDigit("2", asEntityName); }
		if (bNumPad3) 	{ Keypad_EnterDigit("3", asEntityName); }
		if (bNumPad4) 	{ Keypad_EnterDigit("4", asEntityName); }
		if (bNumPad5) 	{ Keypad_EnterDigit("5", asEntityName); }
		if (bNumPad6) 	{ Keypad_EnterDigit("6", asEntityName); }
		if (bNumPad7) 	{ Keypad_EnterDigit("7", asEntityName); }
		if (bNumPad8) 	{ Keypad_EnterDigit("8", asEntityName); }
		if (bNumPad9) 	{ Keypad_EnterDigit("9", asEntityName); }
		if (bNumPad0) 	{ Keypad_EnterDigit("0", asEntityName); }
		if (bNumPadAst)	{ Keypad_EnterDigit("*", asEntityName); }
		if (bNumPadHash){ Keypad_EnterDigit("#", asEntityName); }
		
	}
	
	//-------------------------------------------------------
	
	void security_keypad_1_GuiEnter(const tString&in asEntityName)
	{
		cLux_AddDebugMessage("Entered keypad GUI");
		msPadCode = "";
		mbUsingKeypad = true;
	}
	
	//-------------------------------------------------------
	
	void security_keypad_1_GuiLeave(const tString&in asEntityName)
	{
		cLux_AddDebugMessage("Left keypad GUI");
		msPadCode = "";
		mbUsingKeypad = false;
	}
    
	void Timer_KeypadEffectsOn(const tString &in asTimer)
	{
		Entity_SetEffectsActive(asTimer, true, false);
		Light_FadeTo(asTimer+"_PointLight_1",cColor_Red,0.1,0);
	}
    
    
    ////////////////////////////////////////////
    /////////////////NOT KEYPAD/////////////////
    ////////////////////////////////////////////
    void OnFlushLeverStateChange(const tString &in asEntity, int alState)
    {
        if (alState!=1)
            return;

        TurnOnPowerSequence("");
    }
    
	cSequenceStatesData mTurnOnPowerSequence;
	void TurnOnPowerSequence(const tString &in asName)
	{
		Sequence_Begin("TurnOnPowerSequence", mTurnOnPowerSequence);

		if (Sequence_DoStepAndWait(3.0f))
		{
            Sound_PlayGui("01_01_upsilon_awake/sfx/wake_up/wake_up_event", 1.0f, eSoundEntryType_Gui);
            Sound_CreateAtEntity("PowerOn", "01_01_upsilon_awake/sfx/wake_up/lights_on", "Player", 0, false);
        }
    }
    
    
    
    array<tString> vAlreadyCalled;
    bool Trigger_DoMessage(const tString &in asParent, const tString &in asChild, int alState)
    {
        array<tString> vMessage = cString_Split(asChild, "_");
        if (vMessage.size()>1)
        {
            tString Message = vMessage[1];
            tString RealMessage = "";
            array<tString> vRealMessage = cString_Split(GetCurrentMessage(), "_");
            if (vRealMessage.size()>1)
                RealMessage = vRealMessage[0];
            
            if ((RealMessage == "") && (vAlreadyCalled.find(Message) < 0)) {
                MakeMessage(Message);
                vAlreadyCalled.insertLast(Message);
            }
        }
        
        return true;
    }
    
    bool Trigger_RemoveMessage(const tString &in asParent, const tString &in asChild, int alState)
    {
        array<tString> vMessage = cString_Split(asChild, "_");
        if (vMessage.size()>1)
        {
            tString Message = vMessage[1];
            tString RealMessage = "";
            array<tString> vRealMessage = cString_Split(GetCurrentMessage(), "_");
            if (vRealMessage.size()>1)
                RealMessage = vRealMessage[0];
            
            if (RealMessage == Message)
                StopMessage();
        }

        
        return true;
    }
	 
	 //} END SCENE X
 
}